<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="Personal website for a frontend developer"/><meta name="og:title" content="kng.nz"/><meta name="twitter:card" content="summary_large_image"/><title>Made a thing: Animated Highlight</title><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/65ccd3fc28cbc766.css" as="style"/><link rel="stylesheet" href="/_next/static/css/65ccd3fc28cbc766.css" data-n-g=""/><link rel="preload" href="/_next/static/css/23a8648c9283e660.css" as="style"/><link rel="stylesheet" href="/_next/static/css/23a8648c9283e660.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2577b34a028992b2.js" defer=""></script><script src="/_next/static/chunks/684-7a39d1eb17d559a6.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-d4aeaedec97e1c69.js" defer=""></script><script src="/_next/static/IcEs7FivOB4QarbyzqP0o/_buildManifest.js" defer=""></script><script src="/_next/static/IcEs7FivOB4QarbyzqP0o/_ssgManifest.js" defer=""></script><script src="/_next/static/IcEs7FivOB4QarbyzqP0o/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><header><h2><a href="/">kng.nz</a></h2></header><main><article><h1>Made a thing: Animated Highlight</h1><div><time dateTime="2022-06-27">June 27, 2022</time></div><div><p>Part of my motivation for making this site is to have a platform for reimplementing cool things that I see across the web as learning exercises.
Yes, it is easy enough to make a small repos every time, but I get bogged down with boilerplate and lose motivation before starting the actual thing.
I saw some blog that had an animated highlight of a key point when you scrolled into view.
So, I copied it.</p>
<p><a href="https://kng.nz/things/animated-highlight">View a demo</a></p>
<p><a href="https://github.com/timdk/kng.nz/tree/main/src/components/shared/highlight">View the source</a></p>
<h2>How does it work?</h2>
<p>The highlight itself is done by animating a coloured background on an element.
If the element is inline then it spans multiple lines nicely.
The background is a linear gradient with no gradient (50/50 two-tone).
It is twice the width of the element, so it appears as just one of the colours.
When we add the second class we animate the background position and the other colour slides in.</p>
<pre><code>.highlight {
  padding: 0 0.2em;
  background-image: linear-gradient(to right, $color 50%, $color-filled 50%);
  background-size: 200% 100%;
  transition: background-position;
  transition-delay: 0.5s;
  transition-timing-function: cubic-bezier(0.65, 1, 1, 1);
}

.filled {
  background-position: -100% 0;
}
</code></pre>
<p>We want the highlight to appear in viewport so use an <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">Intersection Observer</a> to apply the class when it appears in the viewport.
I configured it with this callback and these options:</p>
<pre><code>const observer = new IntersectionObserver((entries) => {
  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      entry.target.classList.add('filled')
    }
  })
}, {
  root: null,
  rootMargin: '0px',
  threshold: 1.0,
})
</code></pre>
<p>If the root node in the options is <code>null</code> it uses the viewport.
Threshold of 1 means it triggers when the entire element is in the viewport.
The <code>transition-delay</code> on the highlight delays it slightly after it becomes visible.</p>
<p>I implemented it as a React component so I added a ref to the node and handle the observer inside the <code>useEffect</code> hook.</p>
<p>During testing, I noticed that with longer text a fixed duration means it animates too fast.
So, I scale the animation duration with the number of characters.
It's currently a linear function, but I think it goes too slow with long texts and a logarithmic function would be better.
It's good enough for now given you probably don't want to highlight big matches of text, just key points.</p>
</div></article></main><div><a href="/posts">‚Üê Back to posts</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"animated-highlight","contentHtml":"\u003cp\u003ePart of my motivation for making this site is to have a platform for reimplementing cool things that I see across the web as learning exercises.\nYes, it is easy enough to make a small repos every time, but I get bogged down with boilerplate and lose motivation before starting the actual thing.\nI saw some blog that had an animated highlight of a key point when you scrolled into view.\nSo, I copied it.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://kng.nz/things/animated-highlight\"\u003eView a demo\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/timdk/kng.nz/tree/main/src/components/shared/highlight\"\u003eView the source\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003eHow does it work?\u003c/h2\u003e\n\u003cp\u003eThe highlight itself is done by animating a coloured background on an element.\nIf the element is inline then it spans multiple lines nicely.\nThe background is a linear gradient with no gradient (50/50 two-tone).\nIt is twice the width of the element, so it appears as just one of the colours.\nWhen we add the second class we animate the background position and the other colour slides in.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.highlight {\n  padding: 0 0.2em;\n  background-image: linear-gradient(to right, $color 50%, $color-filled 50%);\n  background-size: 200% 100%;\n  transition: background-position;\n  transition-delay: 0.5s;\n  transition-timing-function: cubic-bezier(0.65, 1, 1, 1);\n}\n\n.filled {\n  background-position: -100% 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe want the highlight to appear in viewport so use an \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\"\u003eIntersection Observer\u003c/a\u003e to apply the class when it appears in the viewport.\nI configured it with this callback and these options:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst observer = new IntersectionObserver((entries) =\u003e {\n  entries.forEach((entry) =\u003e {\n    if (entry.isIntersecting) {\n      entry.target.classList.add('filled')\n    }\n  })\n}, {\n  root: null,\n  rootMargin: '0px',\n  threshold: 1.0,\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the root node in the options is \u003ccode\u003enull\u003c/code\u003e it uses the viewport.\nThreshold of 1 means it triggers when the entire element is in the viewport.\nThe \u003ccode\u003etransition-delay\u003c/code\u003e on the highlight delays it slightly after it becomes visible.\u003c/p\u003e\n\u003cp\u003eI implemented it as a React component so I added a ref to the node and handle the observer inside the \u003ccode\u003euseEffect\u003c/code\u003e hook.\u003c/p\u003e\n\u003cp\u003eDuring testing, I noticed that with longer text a fixed duration means it animates too fast.\nSo, I scale the animation duration with the number of characters.\nIt's currently a linear function, but I think it goes too slow with long texts and a logarithmic function would be better.\nIt's good enough for now given you probably don't want to highlight big matches of text, just key points.\u003c/p\u003e\n","title":"Made a thing: Animated Highlight","date":"2022-06-27"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"animated-highlight"},"buildId":"IcEs7FivOB4QarbyzqP0o","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>